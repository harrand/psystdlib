static if(_win32)
{
	SECURITY_ATTRIBUTES ::= struct
	{
		nLength : u32;
		lpSecurityDescriptor : v0?;
		bInheritHandle : s32;
	};
	STARTUPINFOA ::= struct
	{
		cb : u32;
		lpReserved : u8?;
		lpDesktop : u8?;
		lpTitle : u8?;
		dwX : u32;
		dwY : u32;
		dwXSize : u32;
		dwYSize : u32;
		dwXCountChars : u32;
		dwYCountChars : u32;
		dwFillAttribute : u32;
		dwFlags : u32;
		wShowWindow : u16;
		cbReserved2 : u16;
		lpReserved2 : u8?;
		hStdInput : u64;
		hStdOutput : u64;
		hStdError : u64;
	};
	PROCESS_INFORMATION ::= struct
	{
		hProcess : u64;
		hThread : u64;
		dwProcessId : u32;
		dwThreadId : u32;
	};
	CreateProcessA ::= func(lpApplicationName : u8?, lpCommandLine : u8?, lpProcessAttributes : SECURITY_ATTRIBUTES?, lpThreadAttributes : SECURITY_ATTRIBUTES?, bInheritHandles : s32, dwCreationFlags : s32, lpEnvironment : v0?, lpCurrentDirectory : u8?, lpStartupInfo : STARTUPINFOA?, lpProcessInformation : PROCESS_INFORMATION? -> s32 ):= extern;
	WaitForSingleObject ::= func(handle : u64, dwMilliSeconds : u32 -> u32 ):= extern;
	GetExitCodeProcess ::= func(hProcess : u64, lpExitCode : u32 mut? -> s32 ):= extern;
}
else
{
	fork ::= func( -> s32) := extern;
	execve ::= func(pathname : u8?, argv : u8??, envp : u8?? -> s32) := extern;
	waitpid ::= func(pid : s32, status : s32 mut?, options : s32 -> s32) := extern;
}

sys_command_impl ::= func(cmd : u8? -> bool)
{
	static if(_win32)
	{
		si : STARTUPINFOA mut := zero;
		pinfo : PROCESS_INFORMATION mut := zero;
		(si.cb) = __sizeof(STARTUPINFOA);
		STARTF_USESTDHANDLES ::= 0x00000100;
		(si.dwFlags) = STARTF_USESTDHANDLES;
		STD_OUTPUT_HANDLE ::= -11@u32;
		STD_ERROR_HANDLE ::= -12@u32;
		(si.hStdOutput) = GetStdHandle(STD_OUTPUT_HANDLE);
		(si.hStdError) = GetStdHandle(STD_ERROR_HANDLE);

		if(CreateProcessA(zero, cmd, zero, zero, true@s32, 0, zero, zero, ref si, ref pinfo) == 0)
		{
			return false;
		}
		WaitForSingleObject(pinfo.hProcess, -1);
		exit_code : u32 mut := 0;
		GetExitCodeProcess(pinfo.hProcess, ref exit_code);
		if(exit_code != 0)
		{
			return false;
		}
		return true;
	}
};

sys_shell_command ::= func(cmd : u8?, cmdlen : u64, a : arena mut? -> bool)
{
	static if(_win32)
	{
		precmd ::= "cmd.exe /C ";
		fullcmd : u8 mut? := arena_alloc(a, 11 + cmdlen + 1);
		memcopy(fullcmd, precmd, zstrlen(precmd));
		memcopy(fullcmd # 11, cmd, cmdlen);
		deref(fullcmd # (11 + cmdlen)) = 0;
		return sys_command_impl(fullcmd);
	}
	else
	{
		cmd_zstr ::= sstr2zstr(cmd, cmdlen, a);
		pid ::= fork();
		if(pid == 0)
		{
			// child
			shell_argv ::= u8?[4]{"sh"; "-c"; cmd_zstr; zero;};
			envp ::= u8?[1]{zero;};
			execve("/bin/sh", argv # 0, envp # 0);
			return false;
		}
		else
		{
			if(pid < 0)
			{
				// fork failed :(
				return false;
			}
			else
			{
				// parent
				status : s32 mut := zero;
				waitpid(pid, ref status, 0);
				// in theory do some error checking
				// but cba lmaooo
			}
		}
		return true;
	}
};

