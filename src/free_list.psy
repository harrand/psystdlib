free_node ::= struct
{
	size : u64;
	next : v0?;
};

// performs memory recycling
free_list ::= struct
{
	head : free_node mut?;
};

free_list_push ::= func(l : free_list mut?, mem : v0? weak, len : u64 -> v0)
{
	if(len < __sizeof(free_node))
	{
		// cant recycle super small allocations.
		// just ignore
		return;
	}
	node ::= mem@free_node mut?;
	deref(node) = free_node
	{
		.size := len;
		.next := l->head@_;
	};
	l->head = node;
};

free_list_pop ::= func(l : free_list mut?, len : u64 -> v0? weak)
{
	cur : free_node mut? mut := l->head;
	prev : free_node mut? mut := zero;
	while(cur != zero)
	{
		if(cur->size >= len)
		{
			// cur is enough
			// let's try to split it
			maybe_newnode ::= _free_node_split(cur, len);
			next : free_node mut? mut weak := maybe_newnode;
			if(next == zero)
			{
				next = (cur->next);
			}
			if(prev != zero)
			{
				prev->next = next;
			}
			else
			{
				l->head = next;
			}
			return cur;
		}
		prev = cur;
		cur = (cur->next@_);
	}
	return zero;
};

free_list_total_size ::= func(l : free_list? -> u64)
{
	cur : free_node mut? mut := l->head;
	total : u64 mut := 0;
	while(cur != zero)
	{
		total = total + (cur->size);
		cur = (cur->next@_);
	}
	return total;
};

free_list_avg_size ::= func(l : free_list? -> u64)
{
	cur : free_node mut? mut := l->head;
	total : u64 mut := 0;
	count : u64 mut := 0;
	while(cur != zero)
	{
		total = total + (cur->size);
		count = count + 1;
		cur = (cur->next@_);
	}
	return total / count;
};

_free_node_split ::= func(node : free_node mut?, threshold : u64 -> free_node mut?)
{
	// if node->size >= threshold, then split the node into two nodes and return the second
	// if we didnt do a split, returns zero
	orig_size ::= node->size;
	if(orig_size >= (threshold + __sizeof(free_node)))
	{
		// we do a split
		node->size = threshold;
		// offset 'threshold' bytes from the node ptr
		// treat that as a new node ptr
		newnode ::= (node@u8? # threshold)@free_node mut?;
		deref(newnode) = free_node
		{
			.size := orig_size - threshold;
			.next := node->next;
		};
		node->next = (newnode@_);
		return newnode;
	}
	return zero;
};
